---
title: "Single Nuclei vs Single cells (non-depleted) -- Normal tissue, 2 patients"
author: "SÃ©bastien Renaut (sebastien.renaut@criucpq.ulaval.ca)"
date: "`r Sys.time()`"
output:
  html_document:
    number_sections: T
params:
  datapath: 'C:/Users/renseb01/Documents/scRNA/scRNA/data'
  outputpath: '../..' 
---

# Setup  
* This is a scRNA project comparing **single cell** versus **single nuclei**. Single cells are non-depleted cells. 2 patients are analysed.
* Note that you can create this document by running:  
  * `Rscript -e "rmarkdown::render('scRNA_seurat_lung_adenocarcino_vSCT_merge_intergrated.RMd',params = list())"` and `knit`-it directly in `RStudio`.
  
```{r, timehook,echo=F}
knitr::knit_hooks$set(timehook = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now)
      # return a character string to show the time
      paste("\n\n\nTime for this code chunk to run:",signif(res,3),attr(res,'units'))
    }
  }
}))
```

```{r, setup,echo=FALSE}
knitr::opts_knit$set(root.dir = params$datapath)
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, cache=FALSE, cache.lazy=FALSE)
```

```{r, requirements}
library(Seurat) #scRNA analyses
library(sctransform) #data normalization
library(scater) #outlier values predictions
library(scAnnotatR) #cell type annotation (devtools::install_github('grisslab/scAnnotatR'))

library(dplyr) #data handling
library(patchwork) #data viz
library(ggplot2) #data viz
library(DT) #data viz

```

# Loading data  
  * `barcodes.tsv.gz`, `features.tsv.gz` and `matrix.mtx.gz` files come directly from  `cell ranger`.


```{r filenames,message  = T, fig.width = 11, fig.height=8,echo=T}  
#filenames =  list.files('.',pattern = '-CST-30.._[aS]',full.names = F)
filenames =  list.files('.',pattern = '-CST-30.._[aS]',full.names = F)
filepaths = file.path(getwd(),filenames,'filtered_feature_bc_matrix')
filenames
```


```{r qc,message  = F, fig.width = 11, fig.height=8,echo=F, timehook = TRUE}  
#create seurat objects
seurat.objects = list()
l = length(filepaths)
#create filters objects
QC_filters=data.frame(nCount_min=rep(0,l),nCount_max=rep(0,l),
                    nFeature_RNA_min=rep(0,l),nFeature_RNA_min=rep(0,l),
                    percent.mt_min=rep(0,l),percent.mt_max=rep(0,l))


for(i in 1:length(filenames)) {
#for(i in 1:4) {
  # Read 10x data
  cts <- Read10X(data.dir = filepaths[i])
  seurat.objects[[i]] = CreateSeuratObject(counts = cts)
  seurat.objects[[i]][["percent.mt"]] <- PercentageFeatureSet(seurat.objects[[i]], pattern = "^MT-")

  # Filters
  QC_filters[i,1:2] = attr(isOutlier(seurat.objects[[i]]@meta.data$nCount),'thresholds')
  QC_filters[i,3:4] = attr(isOutlier(seurat.objects[[i]]@meta.data$nFeature_RNA),'thresholds')
  QC_filters[i,5:6] = attr(isOutlier(seurat.objects[[i]]@meta.data$percent.mt),'thresholds')
  
  # Subset
  seurat.objects[[i]] <- subset(seurat.objects[[i]], subset = percent.mt <  QC_filters[i,6])

  # Generate metadata
  temp = strsplit(filenames[i],split = '_')[[1]]
  meta = c(filenames[i],temp[2],ifelse(regexpr('CST',temp[1])>0,'normal','tumor'),strsplit(temp[1],fixed = T,'-')[[1]][2])
  seurat.objects[[i]]@meta.data$samplename = temp[1]
  seurat.objects[[i]]@meta.data$method = temp[2]
  seurat.objects[[i]]@meta.data$type = ifelse(regexpr('CST',temp[1])>0,'normal','tumor')
  seurat.objects[[i]]@meta.data$patient = ifelse(regexpr('301',temp[1])>0,'P4','P6')
  
  # Normalisation
  seurat.objects[[i]] <- SCTransform(seurat.objects[[i]], method = "glmGamPoi", vars.to.regress = "percent.mt", verbose = F)
  
  # Cell Type Identification
  if(i ==1) {hlca_models <- scAnnotatR::load_models("C:/Users/renseb01/Documents/scRNA/scRNA/data/HLCA/models/");
  hlca_models = hlca_models[-41]} # 41 ( CD8 T cells ) causes a problem...not sure why.
  
  temp <- try(classify_cells(classify_obj = seurat.objects[[i]], 
               assay = 'SCT', slot = 'counts',
               classifiers = hlca_models),TRUE)
  
  if(class(temp)!='try-error') {
    seurat.objects[[i]] = temp;
    matches = read.csv('../data/HLCA/cell_types_matches.csv')

    #coarsed annotation inference (level 1):
    seurat.objects[[i]]@meta.data$ann_level_1_mpct  = 'unknown'
      for(j in seq_along(seurat.objects[[i]]@meta.data$ann_level_1_mpct))
        {
          temp_match = matches$ann_finest_level_recoded == seurat.objects[[i]]@meta.data$most_probable_cell_type[j]
          if(length(temp_match[temp_match]) == 1) seurat.objects[[i]]@meta.data$ann_level_1_mpct[j] = matches$ann_level_1[temp_match] 
        }
    }
  
  if(class(temp)=='try-error') {print(temp)}
  
  print(paste0(i,' --- Time: ',Sys.time(),' -- seurat object ready (subsetting, classification, normalisation)'))
}

names(seurat.objects) =  filenames

print(seurat.objects)
```


# Filters defined with isOutlier()
```{r DTfilter,echo =F, message = T} 
rownames(QC_filters) = filenames
QC_filters = signif(QC_filters,4)
datatable(QC_filters,caption = htmltools::tags$caption(htmltools::strong("Filters as calculated by isOutlier()"), style="color:darkred"), options = list(dom = 't'))
```

  

# Cell types annotations summaries
  * **Single Nuclei** are enriched lung specific cell types ( *AT1*, *AT2*, *transitional AT2*).
  * **Single Cells** are enriched in immune system related cells types (*macrophages*,  *NK*, *moncytes*, *DC2*).  
  * Around 80% of cells are annotated, which is pretty good.  
```{r celltypes,echo = F} 
final_summary = list()
for(level in c('most_probable_cell_type','ann_level_1_mpct'))
  {
    cell_type_summary = list()
    CTS_fractions = list()
    for(i in seq_along(filenames))
      {
      cell_type_summary[[i]] = table(seurat.objects[[i]]@meta.data[,colnames(seurat.objects[[i]]@meta.data) == level])
      CTS_fractions[[i]] = signif(cell_type_summary[[i]]/sum(cell_type_summary[[i]])*100,4)
    }
    
  all = merge(as.data.frame(CTS_fractions[[1]]),as.data.frame(CTS_fractions[[3]]),by= 'Var1',all =T)
  sn  = merge(as.data.frame(CTS_fractions[[2]]),as.data.frame(CTS_fractions[[4]]),by= 'Var1',all =T)
  sn_all = merge(sn,all,by = 'Var1',all = T)
  sn_all = sn_all[order(sn_all$Var1),]

  colnames(sn_all) = c('LungCellTypes','Single nuclei - P4','Single nuclei - P6','Single cells - P4','Single cells - P6')
  sn_all$LungCellTypes = as.character(sn_all$LungCellTypes)
  sn_all[nrow(sn_all)+1,1] = c('Total number of cells')
  sn_all[nrow(sn_all),-1] = lapply(cell_type_summary,sum)

  if(level == 'most_probable_cell_type') final_summary[[1]] = sn_all
  if(level == 'ann_level_1_mpct') final_summary[[2]] = sn_all
  }

datatable(final_summary[[1]],caption = htmltools::tags$caption(htmltools::strong("Predicted Cell Types (fraction of total)"), style="color:darkred"))
  
datatable(final_summary[[2]],caption = htmltools::tags$caption(htmltools::strong("Predicted Cell Types (fraction of total)"), style="color:darkred"))


```


# Integration
  * Here, we follow the [most up-to-date approach of Seurat](https://satijalab.org/seurat/articles/integration_introduction.html#performing-integration-on-datasets-normalized-with-sctransform-1) to integrate different single-cells samples together.
  * This is a computationally expensive step that scales greater than linearly with dataset size, so proceed with caution.
```{r integration, echo = T, message = F,  timehook = TRUE}
features <- SelectIntegrationFeatures(object.list = seurat.objects, nfeatures = 2000)
seurat.objects <- PrepSCTIntegration(object.list = seurat.objects, anchor.features = features)
adeno.anchors <- FindIntegrationAnchors(object.list = seurat.objects, normalization.method = "SCT",anchor.features = features)
adeno.combined.sct <- IntegrateData(anchorset = adeno.anchors, normalization.method = "SCT")

```


# Dimensionality reduction
  * Following the common Seurat approach (i.e. *PCA* & *UMAP*).  
```{r dimensionality reduction, echo = F, message = T, timehook = TRUE,fig.width = 11,fig.height=8}
npc = 30
message(paste0('Keeping the first ',npc, ' Principal Components for UMAP'))
adeno.combined.sct <- RunPCA(adeno.combined.sct, verbose = FALSE)
adeno.combined.sct <- RunUMAP(adeno.combined.sct, reduction = "pca", dims = 1:npc)


p1 <- DimPlot(adeno.combined.sct, reduction = "umap", group.by = "samplename")
p2 <- DimPlot(adeno.combined.sct, reduction = "umap", group.by = "method",cols=c('darkblue','yellow'))
p3 <- DimPlot(adeno.combined.sct, reduction = "umap", group.by = "ann_level_1_mpct", cols = 'Set1') + ggtitle("Cell Type Annotation (coarse)")
p1
p2
p3
```

# Optimal number of clusters
  * Following the common Seurat approach (i.e. *FindNeighbors()* & *FindClusters()*).  
```{r optimal number of clusters, echo = F, message = T, timehook = TRUE,fig.width = 11,fig.height=8}
resolution = 0.5
message(paste0('Cluster resolution parameter is set at ',resolution))
adeno.combined.sct <- FindNeighbors(adeno.combined.sct, reduction = "pca", dims = 1:30)
adeno.combined.sct <- FindClusters(adeno.combined.sct, resolution = resolution)
p4 = DimPlot(adeno.combined.sct, reduction = "umap",label = T,group.by =  'integrated_snn_res.0.5') + theme(legend.position = "none")

p4
```




# Assigning cell type to representative Single-Nuclei and Single-Cells clusters  
  * Here, we plot the cell composition of 5 represensative clusters mainly composed of either **Single Cells** or **Single Nuclei** (We omit the unknown cells & cell types with less than 100 cells in a cluster). Again:   
    * **Single Cells** are highly biased (but not entirely composed) in Immune-specific cells.
    * **Single Nuclei** are highly biased in lung specific cells.
    
    
```{r assessing cell type,message=T,echo=F,eval=T,fig.width = 11,fig.height=8}
###

#summarise, removing unknown assignments...
ct_summarised <- adeno.combined.sct@meta.data %>%
  group_by(most_probable_cell_type,integrated_snn_res.0.5,ann_level_1_mpct,.drop=F) %>% 
  summarise(n = length(integrated_snn_res.0.5),.groups='keep')
#%>% filter(most_probable_cell_type!='unknown')

ct_summarised_SN <- adeno.combined.sct@meta.data %>%
  group_by(most_probable_cell_type,integrated_snn_res.0.5,.drop=) %>% 
  summarise(n = length(integrated_snn_res.0.5),.groups='keep') %>% 
  filter(integrated_snn_res.0.5 == 23|integrated_snn_res.0.5 == 5|integrated_snn_res.0.5 == 10|integrated_snn_res.0.5 == 14|integrated_snn_res.0.5 == 8|integrated_snn_res.0.5 == 6) %>%
  filter(n>100) %>% filter(most_probable_cell_type!='unknown')

ct_summarised_ALL <- adeno.combined.sct@meta.data %>%
  group_by(most_probable_cell_type,integrated_snn_res.0.5,.drop=) %>% 
  summarise(n = length(integrated_snn_res.0.5),.groups='keep') %>% 
  filter(integrated_snn_res.0.5 == 11|integrated_snn_res.0.5 == 13|integrated_snn_res.0.5 == 2|integrated_snn_res.0.5 == 16|integrated_snn_res.0.5 == 18) %>%
  filter(n>100) %>% filter(most_probable_cell_type!='unknown')


p5_SN = ggplot(data=ct_summarised_SN, aes(y=n, x=integrated_snn_res.0.5, fill = most_probable_cell_type)) + 
    geom_bar(stat="identity") + 
    labs(title= "Most representatives Single Nuclei clusters",y = "Nb of cells", x = "cell clusters") + 
    scale_x_discrete(guide = guide_axis(angle = 90)) +
    guides(fill = guide_legend(nrow = 20)) + scale_fill_brewer(palette="Set1")

p6_ALL = ggplot(data=ct_summarised_ALL, aes(y=n, x=integrated_snn_res.0.5, fill = most_probable_cell_type)) + 
    geom_bar(stat="identity") + 
    labs(title= "Most representatives Single Cells clusters",y = "Nb of cells", x = "cell clusters") + 
    scale_x_discrete(guide = guide_axis(angle = 90)) +
    guides(fill = guide_legend(nrow = 20))  + scale_fill_brewer(palette="Set3")

p6_ALL + p5_SN 
```


# Cell type annotations: datatable  
```{r cell types DT,echo=F}
celltype_finest_DT = xtabs(n ~ most_probable_cell_type+integrated_snn_res.0.5, ct_summarised,sparse = F)
celltype_finest_DT_matrix = matrix(as.vector(celltype_finest_DT),nrow = nrow(celltype_finest_DT), ncol = ncol(celltype_finest_DT))
colnames(celltype_finest_DT_matrix) = paste0('cluster',colnames(celltype_finest_DT));rownames(celltype_finest_DT_matrix) = rownames(celltype_finest_DT)

datatable(celltype_finest_DT_matrix,caption = htmltools::tags$caption(htmltools::strong("Predicted Cell Type Annotations per cluster"), style="color:darkred"))


###
celltype_level1_DT = xtabs(n ~ ann_level_1_mpct+integrated_snn_res.0.5, ct_summarised,sparse = F)
celltype_level1_DT_matrix = matrix(as.vector(celltype_level1_DT),nrow = nrow(celltype_level1_DT), ncol = ncol(celltype_level1_DT))
colnames(celltype_level1_DT_matrix) = paste0('cluster',colnames(celltype_level1_DT));rownames(celltype_level1_DT_matrix) = rownames(celltype_level1_DT)

datatable(celltype_level1_DT_matrix,caption = htmltools::tags$caption(htmltools::strong("Predicted Cell Type Annotations per cluster"), style="color:darkred"))

```

# Top DEGs, comparing clusters
  * This compares each cluster separately against all others and looks for differentially expressed genes (DEGs). It then reports the top2 distinguishing features (based on FoldChange) for each cluster.
  * This analysis is a bit naive, and a bit more of a P-O-C of what we can compare.
```{r top DEGs, eval = T, echo = F, fig.width = 11, fig.height=6}
# find markers for every cluster compared to all remaining cells, report only the positive ones

adeno.combined.sct.markers <- FindAllMarkers(adeno.combined.sct,
                                              only.pos = TRUE,
                                              min.pct = 0.5,
                                              max.cells.per.ident = 100,
                                              logfc.threshold = 1)

#give me only the top 2 DEGs for each cluster.
topmarkers = adeno.combined.sct.markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_log2FC) 

#Dot Plot
plot_dot = DotPlot(adeno.combined.sct, features = unique(topmarkers$gene), cols = c("darkblue", "yellow"), dot.scale = 8) + RotatedAxis()
plot_dot

```

# Top DEGS, comparing conditions (i.e. Single cell vs Single Nuclei), per cluster
  * Cluster 9 is a nice mix of **Single cell** and **Single Nuclei** cells. Let's examine top DEGs in this comparison. 
  * (NOT RUN)
```{r degs per conditions,echo =F, eval=F}
topmarkers = FindMarkers(adeno.combined.sct, group.by = 'method',ident.1 = 'SN',subset.ident = '9')

#give me only the top 2 DEGs for each cluster.
topmarkers = topmarkers[topmarkers$p_val_adj<0.01,]
topmarkers =topmarkers[abs(topmarkers$avg_log2FC)>1,]
topmarkers = topmarkers[order(abs(topmarkers$avg_log2FC),decreasing=T),]


cluster9 <- subset(adeno.combined.sct, idents = "9")
Idents(cluster9) <- "method"

avg.cluster9 <- as.data.frame(log1p(AverageExpression(cluster9, verbose = FALSE)$RNA))
avg.cluster9$gene <- rownames(avg.cluster9)

p1 <- ggplot(avg.cluster9, aes(all, SN)) + geom_point() + ggtitle("CLUSTER 9")
p1 <- LabelPoints(plot = p1, points = rownames(topmarkers)[1:5], repel = TRUE)

plots <- VlnPlot(adeno.combined.sct, features = rownames(topmarkers)[1:5], split.by = "method", group.by = "integrated_snn_res.0.5",pt.size = 0, combine = FALSE)
wrap_plots(plots = plots, ncol = 1)

```

# session info  
```{r session, message= T}
###session
sessionInfo()
```






